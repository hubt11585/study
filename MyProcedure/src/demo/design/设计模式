                                                 java设计模式整理

一、创建型模式

1、抽象工厂模式(AbstractFactory): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类.
   案例：https://www.cnblogs.com/lfxiao/p/6811820.html

2、生成器模式(Builder): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.
   案例：https://www.cnblogs.com/zhuyuliang/p/5212746.html

3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.
   案例：https://www.cnblogs.com/zailushang1996/p/8601808.html

4、原型模式(prototype): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原形模式.
   案例：https://www.cnblogs.com/lfxiao/p/6812835.html

5、单例模式(single): 确保一个类只有一个实例, 并提供全局访问点.
   案例：https://www.cnblogs.com/t0000/p/8250686.html

6、多例模式(multition): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.
   案例：http://www.cnblogs.com/borter/p/9590579.html

7、静态工厂(StaticFactory)
   案例：https://www.cnblogs.com/xt0810/p/3623355.html

二、结构型模式

1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承.
   案例：https://www.cnblogs.com/V1haoge/p/6479118.html

2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.
   案例：https://www.cnblogs.com/lfxiao/p/6815760.html

3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现"整体/部分"层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.
   案例：https://www.cnblogs.com/lfxiao/p/6816026.html

4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案.
   案例：https://www.cnblogs.com/lzb1096101803/p/4425483.html

5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用.
   案例：https://www.cnblogs.com/lfxiao/p/6816900.html

6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多"虚拟实例", 就使用蝇量模式.
   案例：https://www.cnblogs.com/lfxiao/p/6817141.html

7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问.
   案例：https://www.cnblogs.com/qifengshi/p/6566752.html

三、行为型模式

1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.
   案例：https://www.cnblogs.com/ysw-go/p/5432921.html

2、命令模式(Command pattern): 将"请求"封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作.
   案例：https://www.cnblogs.com/jingmoxukong/p/4234281.html

3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器.
   案例：https://www.cnblogs.com/java-my-life/archive/2012/06/19/2552617.html

4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示.
   案例：https://www.cnblogs.com/ysw-go/p/5384516.html

5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式.
   案例：https://www.cnblogs.com/ysw-go/p/5413958.html

6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求"撤销"), 你使用备忘录模式.
   案例：https://www.cnblogs.com/java-my-life/archive/2012/06/06/2534942.html

7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.
   案例：https://www.cnblogs.com/luohanguo/p/7825656.html

8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.
   案例：https://www.cnblogs.com/pony1223/p/7518226.html

9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.
   案例：https://www.cnblogs.com/MrRightZhao/p/8000421.html

10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤.
   案例：https://www.cnblogs.com/liaoweipeng/p/5790395.html

11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.
   案例：https://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html